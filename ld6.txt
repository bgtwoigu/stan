可执行文件装载与进程
原因:可执行文件被装载到内存后才能被CPU执行.

===进程虚拟地址空间===
每个程序允许起来以后会有对应的私有的虚拟地址空间,进程只能使用操作系统分配的地址,非法访问其他空间会被系统强制终止,并会有相应的错误反馈,例如linux的"segmentation fault".

对于32位的系统,理论上一共虚拟空间是4GB,linux里除去系统自占用的0xC0000000到0xFFFFFFFF的1GB,剩下的0x00000000到0xC0000000的3GB就是理论上最大进程可以使用分配的虚拟空间;对于Windows来说系统会占用2G的内存,但是可以修改系统盘根目录下的Boot.ini文件(加上参数"/3G")让其也只占用1GB的内存.

PAE(物理地址扩展),扩展地址线的位数到36位,修改页映射方式.
AWE(Address Windowing extensions),系统提供一个串口映射将上述哪些额外的内存映射到进程地址空间中去.
以上这两种win端的方法也可以通过修改Boot.ini实现.(加参数"/AWE","/PAE")

linux端用mmap()的系统调用实现.

===装载的方式===
动态装入:根据使用频率选择哪些指令和数据可以驻留在内存中.
[1]覆盖装入
程序员分析模块之间的调用依赖关系组织后,编写一个辅助代码(覆盖管理器overlay_manager),自定义需要载入的模块的时机,无调用依赖关系之间的模块可以互相覆盖.
[2]页映射
所有的数据和指令按照"页"为单位来划分,不满一页的记做一页,程序的数据和指令也按照相同大小分页来装载进入,当内存已满而程序还需要再装入新的指令或数据,则需要根据一些特定算法(FIFO,LUR使用频率)去放弃掉某一些页上的内容,这也是现在ELF和PE文件的装载方式.

===可执行文件的装载===
为了避免每次新的数据指令装入页时都要进行重定位,所以出现物理地址和虚拟地址之间映射关系的建立.
[1]建立进程
创建虚拟地址空间:一个虚拟空间由一组页映射函数将虚拟空间的各个页映射到对应的物理空间(实际内存),所以需要创建映射函数所需要的数据结构,然后分配一个页目录即可.

读取可执行文件头文件:建立虚拟空间和可执行文件的映射关系,程序发生页错误时,系统从物理内存中分配一个页去装载需要的指令或数据,在这个时候即可将此时的物理页和缺少可执行文件的虚拟地址页对应起来,形成映射关系,这是最重要的一步.(此时的可执行文件其实是映像文件,对应看到的也是被映射的虚拟空间地址)
PS:映射关系建立后,会根据虚拟地址形成各种VMA(虚拟内存地址区域)段,凡是对应有虚拟空间地址区间的,都是VMA.

将CPU指令寄存器设置为可执行文件入口,启动运行:操作系统通过设置的指令寄存器将控制权交给进程,进入可执行文件的入口地址,开始执行程序.(细节部分会涉及内核和用户堆栈之间的切换,CPU运行权限的变换等等)

[2]页错误
可执行文件入口地址获得,启动程序-->入口地址处是个空页面,发生页错误-->操作系统重新获得控制权,查询这个缺失空页面对应的VMA-->得到VMA在可执行文件的具体位置对应到进程虚拟空间的虚拟地址页-->物理内存中分配一个新的物理页-->物理页和虚拟页建立映射关系-->控制权还回进程,再次开始执行程序.

0x08048000是linux默认段开始的虚拟地址.

===进程虚拟空间分布===
[1]ELF文件链接视图和执行视图
为了避免过多段而在映射到虚拟空间时造成使用大量的页但只占用了其中很小的空间,所以以权限来区分并合并相同权限的段(可读可写可执行,可读可读,只读),这样合并之后的段集合被称为"segment",装载时就以"segment"为单位去实现页映射过程,这样一个segment对应着一个VMA.

readelf -l target.elf	//查看可执行文件的程序头,包含着segment的分割信息,就类似ELF目标文件的段表包含着段的属性信息一样
程序头的结构体详细见P188

对于ELF文件的划分,section-->链接视图,segment-->执行视图.

[2]堆heap/栈stack
./target.elf &	//获得系统为进程分配的虚拟空间值?
cat /proc/21963/maps	//得到21963这个虚拟空间里进程被分配的segment对应的VMA,这里面也有堆和栈对应的AVMA(匿名虚拟内存区域),还有一个vdso的VMA虚拟区间(一个内核的模块).

segment在占据多个页时,系统可能会把最后一个页剩下的部分清零,结束这一个segment的映射后,调用内核的函数do_brk()将之前清除掉的部分放在下一个VMA中,这种现象通常出现在可读可写的数据段的VMA和堆段的VMA之间,前一个segment对应的VMA把例如bss段的内容放在了堆对应的VMA中.

[3]堆的最大申请数量












































