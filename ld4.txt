==静态链接==

===空间和地址分配===
将两个目标文件a.o和b.o当做输入,输出即可执行文件"ab",其中的代码段,数据段等等都是互相合并得到.
[1]按序叠加,按照顺序分别将目标文件一个个叠加起来,目标文件多的情况下,会有很多零散段出现,然而每一个段都会要求有一定的地址和空间对齐,x86的段装载空间对齐单位是一"页"(4K),段数量越多,空间浪费越多.
[2]相似段合并,每个目标文件的相同段(例如text段)合并成一个段,再叠加起来.

这里说的分配空间的意义只局限于虚拟地址空间.

$ld a.o b.o -e main -o ab;		//-e main表示将main函数作为程序入口
两步链接:
扫描所有的目标文件,获取所有段的各种属性,将目标文件的所有符号放入一个全局符号表里,将相同的段合并,计算出合并后段的长度位置等等,建立映射关系;
使用上一步收集到的信息,进行符号解析和重定位,调整代码中的地址等等.

通过查看链接后的"ab"的ELF文件头中VMA和LMA,说明虚拟空间是链接过程才进行分配,
linux中,ELF可执行文件虚拟地址默认从0x08048000开始分配.(而不是一般理想中的0x00000000开始分配)

[3]符号地址确定
段初始地址+符号所在该段的偏移量

===符号解析和重定位===
通过目标文件的反汇编"objdump -d",可以看到代码段的所有字节和相关的所有指令,a.c被编译为目标文件是,编译器并不知道其中引用变量的地址,它们都定义着b.c中,所以会暂时将其地址当做"0",链接中完成了空间个地址分配时,即链接器就会修正对应未知"符号"的地址,这个过程就叫做重定位.

修正后的地址就是它们的真正的被分配到的虚拟地址,汇编call指令后跟的调用指令的下一条的偏移量,call指令所在偏移量是80480bf,和下一条指令的相对偏移量是0x09,则要求的符号的偏移量为"80480c8".(指令修正/地址计算方式???)

重定位表:
保存重定位相关的信息,重定位的目标,调整方式等等.
objdump -r target.o		//只显示目标文件需要重定位相关的地方,即哪些外部引用的符号,每一个符号都可以当做是一个重定位入口.
重定位表的结构体:
typedef struct{
	Elf32_addr r_offset;	//重定位入口偏移,需要修正的位置在所在段的偏移量
	Elf32_Word r_info;		//重定位入口类型和符号,这个成员的低8位表示重定位入口类型,高24位表示重定位入口的符号在符号表中的下标.
}Elf32_rel;

符号解析:
链接中如果输入的目标文件缺少某一些符号的定义或者是库文件,都会出现"未定义的引用"这样的错误,可以用"readelf -s"查看目标文件的符号表,看有哪些符号是属于"UND"的,这些即是外部引用的符号,需要去找到相应的定义这些符号的外部目标文件.

指令修正方式:
修正方式取决于使用的处理器平台,32位的x86平台重定位入口修正的指令寻址方式有两种.

绝对近址32位寻址	R_386_32	1	S+A
相对近址32位寻址	R_386_PC32	2	S+A-P
//S-符号实际地址,A-保存在被修正位置的值,P-被修正的位置,即修正位置在所在段的偏移量or虚拟位置(r_offset).
//绝对寻址修正修正后的结果即该符号的实际地址,相对寻址修正的结果等于修正位置的偏移量和符号目标位置偏移量的差值.

===Common块===
事前声明使用空间的大小,这种空间叫做common块.

common类型链接规则都是针对弱符号的.

多个弱符号或强符号类型不一致,链接器只知道符号的"名字",无法区别类型的不同.
多个弱符号-->取长度最长的那个;
弱符号和强符号-->取强符号;
强符号和强符号-->报错,不能重复定义强符号;
弱符号长度比强符号长-->报错,强符号长度比弱符号短;

之所以之前不会吧未初始化的全局变量也放入bss段也是因为可能在其他目标文件中有相同的弱符号出现,因此不能确定这些未定义的初始化全局变量的长度,因此也无法放入bss段中去为其预先分配空间,但是最终链接过程中读取所有输入目标文件后,确定长度后就可以放入BSS段了.

gcc用"-fno-common"在编译中来把所有未初始化的全局变量不以common块的形式处理,也可以用"int global _attribute_((nocommon))"处理单个符号.

===C++相关问题===

































