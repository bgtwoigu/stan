===Gecko===
如同之前提到的那样，火狐系统的的gecko对web标准作出定义，并控制着手机硬件设备之间的交互。
web应用利用安全的web-API控制着硬件，web-API提供了面向下层的硬件设备的可编程接口，web的内容会通过使用HTML5语言来访问到这些API。
一个应用包含各种由HTML5编写的web内容，去构建一个web应用需要你在火狐系统的手机上进行组装，打包，分发等等。
web引用在火狐系统的运行环境下run-time，对其的web内容进行解释，编译，并在这个web的引擎中渲染。

图-gecko结构图
【1】gecko结构
最上层和gaia层相连的是火狐系统的run-time，由它和下面的权限管理器相连。

安全性框架包含如下：
权限管理器，web-API中会涉及到的各种接入功能的权限控制
接入控制列表，web-API中涉及到的接入功能和权限的矩阵列表
证书验证，用户及各个应用的鉴权
权限存储部分，接入web-API所需的特权设定存储集

web-API：
标准的API集，将硬件的功能调用开放给上层，提供安全，可编程的接口，同时伴随数据的存储。

IO：
面向硬件和数据存储设备的接口

软件更新：
各种web应用的更新和第三方的应用

布局和渲染：
gecko引擎会去解析并运行网页内容，依规定的形式向上层即用户展示

b2g进程：
作为gecko的底层部件，和面向gonk的接口，是一个拥有特权高优先级的系统进程，将各种应用作为子进程启动管理。

【2】和火狐系统相关的gecko的各类文件介绍
b2g/：包含了火狐系统主要相关的函数

b2g/chrome/content：包含了运行在系统应用上的js文件

b2g/chrome/content/shell.html：对gaia层的入口，系统应用必须的html文件，shell.html文件关联了setting.js和shell.js这两个文件，settings.js包含了系统默认的设置参数，
	
	<script type="application/javascript;version=1.8" src="chrome://browser/content/settings.js"> </script>
	<script type="application/javascript;version=1.8" src="chrome://browser/content/shell.js"> </script>

b2g/chrome/content/shell.js：这个文件是在gaia层第一个被加载的系统应用，它会引入更多的需求模块，定义“sendCustomEvent”和“sendChromeEvent”去和gaia进行交互，提供之后的web应用的安装帮助，诸如indexedDB quota，RemoteDebugger，keyboard helper，screenshot tool之类。
总之该文件最重要是去启动gaia系统应用，然后将整个系统的管理工作都交给这个gaia的上层应用。

	let systemAppFrame =
	  document.createElementNS('http://www.w3.org/1999/xhtml', 'html:iframe');
		...
	  container.appendChild(systemAppFrame);
  
b2g/app/b2g.js：该文件包含了预定义的设置，就像浏览器的设置文件一样，作用等同于gaia的pref.js文件，这些设置自己都是可以在设置中进行更改的，当然也可以在gaia的user.js中对其进行完全的重写再编译该脚本文件。
----------
dom/{API}
新提供的API陈述都会放在dom/目录下，那些旧的API会放在dom/base/目录下，例如navigator.cpp

dom/apps：加载.jsm文件，.js的API陈述例如webapp.js会被安装得到其本身。

dom/apps/PermissionsTable.jsm：包含所有的权限定义都放在这个文件里。
----------
dom/webidl：webIDL是在定义web-API时用到的“特定语言”，更多内容可以参考如下。https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings

hal/gonk：该目录包含和gonk层移植相关的文件。

----------
module/libpref/src/init/all.js：所有的配置文件。

/system/b2g/omni.ja和/system/b2g/omni.js：设备里资源的pack类型/Contains the pack of styles for resources in the device.

【3】处理输入事件
在gecko层中发生最多的事件就是用户操作的触发事件，诸如在上层你按下按钮，对屏幕的触屏操作等等都会以“输入事件”的方式表现反馈回上层，这些操作事件通过gonk里的一个nsIAPPShell进入到gecko，这是一个gecko的接口用于表示gecko应用的入口点，因此当输入设备驱动调用nsAPPShell对象时，gecko子系统就会发送对应的事件给上层的用户接口。
https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIAppShell
http://mxr.mozilla.org/mozilla-central/source/widget/gonk/nsAppShell.cpp

	void GeckoInputDispatcher::notifyKey(nsecs_t eventTime,
										 int32_t deviceId,
										 int32_t source,
										 uint32_t policyFlags,
										 int32_t action,
										 int32_t flags,
										 int32_t keyCode,
										 int32_t scanCode,
										 int32_t metaState,
										 nsecs_t downTime) {
	  UserInputData data;
	  data.timeMs = nanosecsToMillisecs(eventTime);
	  data.type = UserInputData::KEY_DATA;
	  data.action = action;
	  data.flags = flags;
	  data.metaState = metaState;
	  data.key.keyCode = keyCode;
	  data.key.scanCode = scanCode;
	  {
		MutexAutoLock lock(mQueueLock);
		mEventQueue.push(data);
	  }
	  gAppShell->NotifyNativeEvent();
	}

这些“事件源”来自于标准LINUX的输入事件系统，火狐系统在这之上加了一个抽象层，向上层提供更适用于该系统的特性和过滤功能。
源码参考，你可以自己修改源码，通过“EventHub::getEvents()”函数创建定义新的“输入事件”：http://mxr.mozilla.org/mozilla-central/source/widget/gonk/libui/EventHub.cpp
图 - EventHub::getEvents函数
一旦事件从gonk层传递到gecko层之后，它们就会被nsAppShell调度分配进入到“dom/”，事件最终由gecko本身使用或者调度给web应用作为反馈的DOM事件。

	一个在dom/里已经封装好的“输入事件”
	static nsEventStatus sendKeyEventWithMsg(uint32_t keyCode,
											 uint32_t msg,
											 uint64_t timeMs,
											 uint32_t flags) {
		nsKeyEvent event(true, msg, NULL);
		event.keyCode = keyCode;
		event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_MOBILE;
		event.time = timeMs;
		event.flags |= flags;
		return nsWindow::DispatchInputEvent(event);
	}

【4】图形功能
在底层上，gecko使用“OpenGL ES 2.0”去画出一个GL的报文，该报文会去封装硬件的“缓冲帧”。这个操作是在gonk层的nsWindow.cpp里面完成，参考代码如下：
	OpenGL ES 2.0：https://www.khronos.org/opengles/2_X/
	nsWindow文件：http://mxr.mozilla.org/mozilla-central/source/widget/gonk/nsWindow.cpp
	gNativeWindow = new android::FramebufferNativeWindow();
	sGLContext = GLContextProvider::CreateForWindow(this);

“FramebufferNativeWindow”类是直接由Android启动，“FramebufferNativeWindow.cpp”
这个使用gralloc-API去将显卡驱动的帧缓存区映射到内存中。

gecko使用它的层级系统将帧内容画在屏幕上，具体发生的过程如下：
1.Gecko draws separate regions of pages into memory buffers. Sometimes these buffers are in system memory; other times, they're textures mapped into Gecko's address space, which means that Gecko is drawing directly into video memory. This is typically done in the method BasicThebesLayer::PaintThebes().
2.Gecko then composites all of these textures to the screen using OpenGL commands. This composition occurs in ThebesLayerOGL::RenderTo().

gecko负责处理渲染需求的web内容的详细在此不做赘述。

【5】HAL
HAL作为火狐系统的硬件抽象层，同时也是被移植的层级之一，它控制底层硬件设备访问系统接口，通过使用c++的API去访问gecko的高层。
这些API在不同平台的实现依赖于自身gecko的HAL，这里的HAL层并不是完全向gecko的js代码开放，这一部分的交互是有web-API来控制操作。

当用户发起一个电话相关的请求，诸如拨号，接入wifi，连接蓝牙等操作，火狐系统的所有相关堆栈都会关联到这一个请求操作，上层发起，gaia层的应用和web内容通过web-API调用尝试访问底层设备，gecko层作为中间层将请求发送给gonk层，gonk层收到请求后触发各种响应，然后初始化建立并由gonk层管理。
-----------------
How the HAL works：
以Vibration这个功能为例，这个API定义在hal/hal.h文件中：
http://mxr.mozilla.org/mozilla-central/source/hal/Hal.h

	void Vibrate(const nsTArray<uint32> &pattern);

//vibrate函数经过上层操作然后被gecko调用向底层传递，gonk层对应的调用函数定义在这里：http://mxr.mozilla.org/mozilla-central/source/hal/gonk/GonkHal.cpp
	
	void Vibrate(const nsTArray<uint32_t> &pattern) {
	  EnsureVibratorThreadInitialized();
	  sVibratorRunnable->Vibrate(pattern);
	}

//发送请求让手机开始震动，同时从而启动了一个新线程，这个新线程定义在“VibratorRunnable::Run”中，主循环过程如下所示：
	
	while (!mShuttingDown) {
	  if (mIndex < mPattern.Length()) {
		uint32_t duration = mPattern[mIndex];
		if (mIndex % 2 == 0) {
		  vibrator_on(duration);
		}
		mIndex++;
		mMonitor.Wait(PR_MillisecondsToInterval(duration));
	  }
	  else {
		mMonitor.Wait();
	  }
	}

//“vibrator_on”函数是gonk层的一个HAL-API，它会控制设备去启动一个震动马达，就内核来说，实际上这个API会使用sysfs向特定内核对象写入一个值，从而去发送相应的控制信息到内核驱动。

-----------------
Fallback HAL API implementations：
当提供的HAL-API出现在某些不完全开放接口的平台，可能需要将HAL-API回退，即提供一些闲置接口函数，需要你自己去编写这个函数实现的具体内容。
		void Vibrate(const nsTArray<uint32_t> &pattern) {
	}
	
-----------------
Sandbox implementations：沙盒实现
不同的web应用和内容运行时具有不同的特权和优先级，需要一个中心进程来管理它们之间可能出现的竞争，所以使用了一个在HAL层中叫做“沙盒”的实现方式，即各进程的代理请求都会通过使用“IPDL”传递给b2g进程。

以之前的那个手机振动的功能为例，“Vibrate()”函数定义在“hal/sandbox/SandboxHal.cpp”文件中：http://mxr.mozilla.org/mozilla-central/source/hal/sandbox/SandboxHal.cpp

	void Vibrate(const nsTArray<uint32_t>& pattern, const WindowIdentifier &id) {
	  AutoInfallibleTArray<uint32_t, 8> p(pattern);

	  WindowIdentifier newID(id);
	  newID.AppendProcessID();
	  Hal()->SendVibrate(p, newID.AsArray(), GetTabChildFrom(newID.GetWindow()));
	}
//发送由PHal接口定义的消息，具体描述在hal/sandbox/PHal.ipdl文件中：http://mxr.mozilla.org/mozilla-central/source/hal/sandbox/PHal.ipdl

	Vibrate(uint32_t[] pattern);
	
//该消息的接受者“HalParent::RecvVibrate()”，函数具体内容如下，定义在文件“hal/sandbox/SandboxHal.cpp”中：http://mxr.mozilla.org/mozilla-central/source/hal/sandbox/SandboxHal.cpp

	virtual bool RecvVibrate(const InfallibleTArray<unsigned int>& pattern,
				const InfallibleTArray<uint64_t> &id,
				PBrowserParent *browserParent) MOZ_OVERRIDE {

	  hal::Vibrate(pattern, newID);
	  return true;
	}

以上流程只是简单展示了消息是如何从上层的内容进程通过gecko传递到gonk，最终通过gonk的HAL层的相关API，完成对实际硬件设备驱动的控制。

【6】DOM API






===RIL===
无线接口层的细节，主要模块部件如下：
rild：
用于专用的调制解调器固件的服务进程。

rilproxy：
rild和b2g进程沟通的接口，rild的代理消息端口。

b2g：
定义在gecko里的关键进程，

Gecko's content process：
“nsIRILContentHelper”接口提供一个XPCOM服务，让它

----------
Communicating from rild to the DOM


3G data：



Related DOM APIs

===WIFI===

WifiWorker.js


DOMWifiManager.js


DHCP



===Network Manager===


===Processes and threads===









