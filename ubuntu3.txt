1.系统调用：
	访问内核的唯一手段，通过软中断实现，促使系统切换到内核态去执行“异常处理程序”(即产生"系统调用相应处理程序"这个动作)
	
	User用户、System系统、Fast Interrupt快速中断、Interrupt中断、Supervisor管理、Abort中止、Undefined未定义
	
	用户模式，运行应用程序的普通模式。限制你的内存访问并且你不能直接读取硬件设备。 
	超级用户模式(SVC 模式)，主要用于 SWI(软件中断)和 OS(操作系统)。这个模式有额外的特权，允许你进一步控制计算机。例如，你必须进入超级用户模式来读取一个插件(podule)。这不能在用户模式下完成。
	中断模式(IRQ 模式)，用来处理发起中断的外设。这个模式也是有特权的。导致 IRQ 的设备有键盘、 VSync (在发生屏幕刷新的时候)、IOC 定时器、串行口、硬盘、软盘、等等...
	快速中断模式(FIQ 模式)，用来处理发起快速中断的外设。这个模式是有特权的。导致 FIQ 的设备有处理数据的软盘，串行端口(比如在 82C71x 机器上的 A5000) 和 Econet。
	IRQ 和 FIQ 之间的区别是对于 FIQ 你必须尽快处理你事情并离开这个模式。IRQ 可以被 FIQ 所中断但 IRQ 不能中断 FIQ。为了使 FIQ 更快，所以有更多的影子寄存器。FIQ 不能调用 SWI。FIQ 还必须禁用中断。如果一个 FIQ 例程必须重新启用中断，则它太慢了并应该是 IRQ 而不是 FIQ。 
	
2.linux的中断和队列
	cat /proc/interrupts 查看现有产生的中断的详细信息
	中断号-irq申请的编号 ， ，中断标志，dev_id-共享中断时的cookie data-通常用于区分共享中断具体由哪个设备发起
	
	通常，顶半部实现登记中断和一些必要寄存器的读取，更繁重的任务留在底半部进行处理，顶半部不能被新的中断打断，底半部可以被新的中断打断
	
	中断申请处理函数：在open函数中执行
	return 正常返回0 不正常返回对应错误信息
	int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char*devname, void *dev_id)
	handler是顶半部处理函数，当其返回值为IRQ_WAKE_THREAD时激活回调，不能被打断，thread_fn是底半部函数，以线程方式运行，可以被打断
	
	irqflags的常见设置：
	IRQF_DISABLED ：当置位了, 这表示一个“快速”中断处理. 快速处理在当前处理器上禁止中断来执行.
	IRQF_SHARED ：这个位表示中断可以在设备间共享. 
 	IRQF_SAMPLE_RANDOM ：这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池，通常不应该被置位
	irqflags 普通中断
	
	void enable_irq(int irq)     使能中断
	void disable_irq(int irq)    屏蔽中断	
	void local_irq_enable(void)  使能本地中断
	void local_irq_disable(void)  屏蔽本地中断
	void free_irq(unsigned int irq，void *dev_id) 释放终端 在close函数中执行
	
	顶半部处理方式
	工作在中断上下文中，且本地cpu的中断处于关闭状态，顶半部处理函数handler会禁止本地中断，不能有任何enable/disable本地中断的动作，
	不能条用任何可能产生睡眠的函数，不应该做需要长时间的处理。否则可能导致系统崩溃。	
	
	底半部处理方式
	可以工作在中断或者进程上下文中，可以被打断，通常的实现方式有tasklet, 工作队列和软中断。
	tasklet：运行在中断上下文中
	工作队列：运行在进程上下文中
	软中断：运行在中断上下文中，通常不会直接使用
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
