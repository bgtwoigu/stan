==谈谈指令集==
Reduced Instruction Set Computer-RISC
Complex Instruction Set Computer-CISC
type				CISI					RISC
指令系统			复杂庞大 				简单精简 
指令数目			一般大于200 			一般小于100 
指令格式 			一般大于4 				一般小于4 
寻址方式 			一般大于4 				一般小于4 
指令字长 			不固定 					等长 
可访存指令 			不加限制 				只有LOAD/STORE指令 
各种指令使用频率 	相差很大 				相差不大 
各种指令执行时间 	相差很大 				绝大多数在一个周期内完成 
优化编译实现 		很难 					较容易
程序源代码长度		较短					较长
控制器实现方式		绝大多数为微程序控制 	绝大多数为硬布线控制
软件系统开发时间	较短 					较长

==所有SW的基础-硬件==
最重要的三个组件: CPU-存储器(内存和磁盘)-I/O控制器
频率的极限之后兴起的SMP(symmetrical multi-processing/对称多核处理器)热潮

==计算机里的层级架构==
应用层----开发工具包
-----操作系统API----*
-------运行库-------
----系统调用接口----*	0x80(linux软中断)	0x2E(win端软中断)
----操作系统内核----
------硬件特性------*
-------硬件层-------

==基于CPU调用程序的运行模式来看计算机的发展==
多道程序(无优先级分别)--->分时系统(多个程序按"时间片"轮转运行)--->多任务系统(程序以"进程"为单位存在,CPU的分配为抢占式)

==设备硬件层-驱动==
1."驱动"程序要考虑所操作硬件的状态,是否为忙状态?读取结果是否正确?从而来调度分配各个请求以达到硬件设备的高性能.
2.HAL - hardware Abstraction layer 硬件抽象层
3.把程序给出的地址抽象化为理想化的虚拟地址,将其和实际的物理地址建立一种映射关系,一个程序只能访问与其对应的独立的虚拟空间,从而在抽象中避免不同程序的内存地址发生重叠的情况.
4.分段(虚拟地址和物理地址映射的一一对应)-->分页(进一步细分,确定"页"的大小,VP/DP/PP各种页,虚拟地址到物理地址的转换页映射用MMU实现,MMU一般是集成在CPU内部的)

==线程(thread)==
1.LWP(轻量级线程-light Weight process):最小单元,由线程ID,指令指针,寄存器集合和堆栈组成.
2.进程由一个或多个线程组成,各线程之间共享进程的全局变量,代码段,数据段,堆栈数据等等.
3.线程的权限:局部变量和TLS(thread local storage)数据是私有的,全局变量,堆栈,程序代码段,打开的文件等等都属于该进程下所有线程的共享资源.
4.调度和优先级:单处理器涉及的"时间片轮换执行",调度之中就会涉及程序运行的优先级判定.(IO密集型线程 > CPU密集型线程)
5.windows对于进程和线程有细分(createProcess和createThread的API),linux里面线程和进程区别不明显,都抽象为"task",多个task组成的一个程序可以看作为一个进程,单个task也就对应一个线程,都有相应的内存空间,执行实体和可用的资源.
6.原子操作:适用于简单的数据读写,交换,修改,删除的场景下,一般以单条指令的操作为主.
7.锁:为了保持数据的同步,在一个线程对一个数据的"操作"未完成之前,不允许其他线程对其访问.(信号量(由一对函数控制信号量数值的增减,这一对函数可以被任何线程调用,允许多个线程进入临界区),互斥体(只允许一个线程进入临界区,只能由该进程自己释放互斥体的"锁"))
8.读写锁/读写自旋锁/顺序锁:允许多个进程同时读操作,写操作视情况而定.
9.可重入:多次被调用,函数自身的内部调用引发的,函数可重入的条件是重复执行不会产生不良后果.(函数不使用全局变量和局部的静态变量,不返回全局变量和局部静态变量的指针,函数本身不调用其他不可重入的函数,函数结果只依赖调用提供的参数,"不依赖单个资源的锁??")
10.过度优化:CPU自身的动态调度可能改变指令的执行顺序,利用"barrier()"来分隔需要顺序执行的指令,让在"barrier()"之前的指令必须先执行完成.

==多线程情况==
1.一对一模型:用户线程和内核线程对应,实现真正意义上的并发,缺点在于一一对应的方式会受内核线程数量的限制,上下文切换的开销也很大会影响效率.
2.多对一模型:用户线程都映射在一个内核线程上,切换有用户态的代码来抽象实现,缺点在于如果一个用户现场阻塞,所有线程都无法正常执行.
3.多对多模型:解决内核线程数量限制问题,也不会因为单一用户现场阻塞造成所有线程不能执行,综合性较好,


























